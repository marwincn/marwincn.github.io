<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Marwin&#39;s Blog</title>
    <link>https://marwincn.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Wed, 01 Sep 2021 15:02:00 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>关于RSS</title>
      <link>https://marwincn.github.io/2020/02/27/%E5%85%B3%E4%BA%8ERSS/</link>
      <guid>https://marwincn.github.io/2020/02/27/%E5%85%B3%E4%BA%8ERSS/</guid>
      <pubDate>Thu, 27 Feb 2020 13:24:41 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;一、RSS是什么&quot;&gt;&lt;a href=&quot;#一、RSS是什么&quot; class=&quot;headerlink&quot; title=&quot;一、RSS是什么&quot;&gt;&lt;/a&gt;一、RSS是什么&lt;/h2&gt;&lt;p&gt;RSS是一种信息聚合的技术，都是为了提供一种更为方便、高效的互联网信息的发布和共享，用更少的时间分享更多的信息。&lt;/p&gt;
&lt;p&gt;简单来说RSS就是以统一的格式发布内容，订阅了某个RSS源的客户端可以接受到该源的更新推送。类似订阅一份报纸后，当天最新的报纸就会准时递到你手中。而由于RSS统一格式的优势，不拘于新闻，各种博客，网站更新，各种app讯息都能订阅，这种统一的概念正是吸引我的地方之一。另外一个吸引我的地方是RSS只会让你接收你想要接收的内容，沉浸式无广告阅读，不会有“猜你喜欢”擅自用AI技术推送消息给你的情况出现。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="一、RSS是什么"><a href="#一、RSS是什么" class="headerlink" title="一、RSS是什么"></a>一、RSS是什么</h2><p>RSS是一种信息聚合的技术，都是为了提供一种更为方便、高效的互联网信息的发布和共享，用更少的时间分享更多的信息。</p><p>简单来说RSS就是以统一的格式发布内容，订阅了某个RSS源的客户端可以接受到该源的更新推送。类似订阅一份报纸后，当天最新的报纸就会准时递到你手中。而由于RSS统一格式的优势，不拘于新闻，各种博客，网站更新，各种app讯息都能订阅，这种统一的概念正是吸引我的地方之一。另外一个吸引我的地方是RSS只会让你接收你想要接收的内容，沉浸式无广告阅读，不会有“猜你喜欢”擅自用AI技术推送消息给你的情况出现。</p><span id="more"></span> <p>其实我接触RSS也才一年，这段时间我就已经抛弃了大部分的资讯类的APP。事实上使我相见恨晚的RSS并不是什么新东西，早在十几年前RSS就出现了，在各种资讯APP群魔乱舞的时代RSS始终存在于一个小圈子里。</p><h2 id="二、如何使用RSS"><a href="#二、如何使用RSS" class="headerlink" title="二、如何使用RSS"></a>二、如何使用RSS</h2><p>想要用RSS来阅读内容首先要有RSS阅读软件，这些软件搜一下就能找到很多，我目前使用的是Reeder（macOS，iPadOS），RSS Reader Prime（IOS，独立开发者制作的良心应用，完全免费）。</p><p><img src="https://i.loli.net/2019/11/30/5V86HYL1qocpg9M.png" alt="https://i.loli.net/2019/11/30/5V86HYL1qocpg9M.png"></p><p>拥有一个RSS阅读器后，需要找到你想要的订阅的RSS源，一般是一个链接，如少数派的RSS源地址是 <a href="https://sspai.com/feed">https://sspai.com/feed</a> 。在阅读器中添加该订阅源后就能获取到最新文章的推送，一般的RSS阅读器都有已读未读，分类，更换主题等功能，阅读体验比资讯APP更好。另外推荐一个RSS源的索引： <a href="https://docs.rsshub.app/">https://docs.rsshub.app/</a> ，里面有各种订阅源可以满足你的需要。</p><p><img src="https://i.loli.net/2019/11/30/ujt9grOMGSQloam.png" alt="https://i.loli.net/2019/11/30/ujt9grOMGSQloam.png"></p><h2 id="三、我制作的RSS工具"><a href="#三、我制作的RSS工具" class="headerlink" title="三、我制作的RSS工具"></a>三、我制作的RSS工具</h2><p>出于对RSS的喜爱，我想给我自己的博客（ <a href="http://www.marwin.cn/">http://www.marwin.cn</a> ）添加RSS功能。事实上很多使用框架搭好的博客，如WordPress都自带了RSS功能，无奈我的博客是自己写的后台加静态的前端页面。于是我写了一个定时抓取博客更新并制作成RSS源的软件，在自己设定的时间周期里，绑定的各种类型的Trigger能爬取想要的内容的更新，然后生成RSS源。目前只将我自己的博客生成了RSS源： <a href="http://api.marwin.cn/rss/blog">http://api.marwin.cn/rss/blog</a> 。以后可以爬取其他各种感兴趣的内容然后订阅。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9gb73yii9j306w04u743.jpg" alt="https://tva1.sinaimg.cn/large/006tNbRwgy1g9gb73yii9j306w04u743.jpg"></p><p>关于这个生成RSS的软件，我上传在自己的git仓库。接下来的计划是为自己的git仓库提供一个web页面，想要了解这个软件可以在这个页面获取副本的仓库链接。</p><blockquote><p>更新：由于现在使用hexo搭建博客，配合hexo-rss插件能够直接发布RSS，本博客RSS地址为：<code>https://marwincn.github.io/blog/rss2.xml</code></p></blockquote>]]></content:encoded>
      
      <comments>https://marwincn.github.io/2020/02/27/%E5%85%B3%E4%BA%8ERSS/#disqus_thread</comments>
    </item>
    
    <item>
      <title>记一次应对挖矿程序的经历</title>
      <link>https://marwincn.github.io/2020/02/27/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%BA%94%E5%AF%B9%E6%8C%96%E7%9F%BF%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%8F%E5%8E%86/</link>
      <guid>https://marwincn.github.io/2020/02/27/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%BA%94%E5%AF%B9%E6%8C%96%E7%9F%BF%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%8F%E5%8E%86/</guid>
      <pubDate>Thu, 27 Feb 2020 13:24:41 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h2&gt;&lt;p&gt;之前为了远程调试redis，于是将服务器上的redis绑定到了公网IP上。后来上redis时发现多了两个key，查看了这两个key发现里面是curl和wget命令，于是猜到有人远程下载了脚本，但是下载的地址已经失效了。后来检查服务器的资源占用，果然cpu占用间断性的会飙到100%，显然被人用来挖矿了。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>之前为了远程调试redis，于是将服务器上的redis绑定到了公网IP上。后来上redis时发现多了两个key，查看了这两个key发现里面是curl和wget命令，于是猜到有人远程下载了脚本，但是下载的地址已经失效了。后来检查服务器的资源占用，果然cpu占用间断性的会飙到100%，显然被人用来挖矿了。</p><span id="more"></span> <h2 id="二、关于漏洞的猜测"><a href="#二、关于漏洞的猜测" class="headerlink" title="二、关于漏洞的猜测"></a>二、关于漏洞的猜测</h2><p>redis绑定到公网IP上很容易中招，网上全是类似的帖子（主要还是安全上没有配置好，然后使用了root用户运行了redis-server，感觉自己的辣鸡服务器不会被人盯上的）。检查了一下redis的配置，dbfilename被设置成～/.ssh/authorized_keys。原来是将自己的ssh公钥存到redis的key，然后备份key就将他的公钥存到了authorized_keys成功免密登录了。</p><p>但是关于之前看到的两个脚本还有一种说法是，将dbfilename设置到/etc/crontabs目录下。crontabs是定时执行任务的工具，会强制执行这个目录的文件，于是脚本得以运行。</p><h2 id="三、解决问题"><a href="#三、解决问题" class="headerlink" title="三、解决问题"></a>三、解决问题</h2><p>第一步关闭redis-server，执行shutdown命令的时候发现无法关闭，可能被动了手脚，于是只能kill掉进程。修改redis配置文件然后重新运行。</p><p>第二步修改ssh的authorized_keys。中间我发现sudo没有权限修改，sudo chmod也不能执行，这里我相当纳闷，root用户也没有权限？后来发现文件是被chattr锁定了，执行chattr -i解除锁定却发现chattr程序被删除了，重新下载chattr然后修改了authorized_keys权限删除了公钥。到现在也才防止了对方继续控制我的服务器。</p><p>第三步要停止挖矿程序。虽然监测到cpu占用率经常到100%，但是top命令却没有找到任何占用高的进程，使用ps 也没有发现。所以说挖矿程序是被隐藏了起来，找不到这个进程要怎么杀掉它。中间我找了各种办法，找操作历史，找时间段修改的文件，到/proc目录下面找也没有什么异常。还有可能是top和ps程序被替换了，使用stat /usr/bin/top发现并没有被修改。就算top，ps程序没有被修改，它们依赖的库可能被修改了，但是排查起来非常麻烦，终于我找到了一个软件unhide（centOS），ubuntu下面也有类似的sysdig可以检测出隐藏的进程。利用unhide很容易就找到了一些隐藏的进程：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8veag1qftj309b0ch74a.jpg" alt="https://tva1.sinaimg.cn/large/006y8mN6gy1g8veag1qftj309b0ch74a.jpg"></p><p>在这些进程里一眼就能看出pamdicks不是什么正经程序。于是google了一下，果然是挖矿程序，据说杀掉这个进程还会继续重启，所以找到进程目录删掉然后建立同名文件用chattr给锁定，再杀掉进程，终于cpu占用降下来了。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8veeoakymj30jo08ymxa.jpg" alt="https://tva1.sinaimg.cn/large/006y8mN6gy1g8veeoakymj30jo08ymxa.jpg"></p>]]></content:encoded>
      
      <comments>https://marwincn.github.io/2020/02/27/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%BA%94%E5%AF%B9%E6%8C%96%E7%9F%BF%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%8F%E5%8E%86/#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用hexo搭建博客</title>
      <link>https://marwincn.github.io/2020/02/05/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</link>
      <guid>https://marwincn.github.io/2020/02/05/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</guid>
      <pubDate>Wed, 05 Feb 2020 12:13:41 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h2&gt;&lt;p&gt;本来在自己的vps上自己写了一个博客，但是很多地方需要自己不断维护，自己写的前端也不太满意所以决定用框架搭一个静态博客部署在github page上，这样也省了在vps上到处迁移。&lt;/p&gt;
&lt;p&gt;我选择了人气比较高的Hexo，记录一下自己搭建的过程，作为官方文档的整理和补充。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>本来在自己的vps上自己写了一个博客，但是很多地方需要自己不断维护，自己写的前端也不太满意所以决定用框架搭一个静态博客部署在github page上，这样也省了在vps上到处迁移。</p><p>我选择了人气比较高的Hexo，记录一下自己搭建的过程，作为官方文档的整理和补充。</p><span id="more"></span> <h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><p>首先确认电脑里有git和npm （安装node.js即可）的支持，以下为macOS上使用homebrew安装，其他安装方式参考搜索引擎。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew install git</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装node.js</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew install node</span></span><br></pre></td></tr></table></figure><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure><p>安装后可以使用hexo命令行，命令文档：<a href="https://hexo.io/zh-cn/docs/commands">文档</a>。</p><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo init &lt;folder&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> &lt;folder&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml     //项目配置文件</span><br><span class="line">├── package.json    //应用程序的信息</span><br><span class="line">├── scaffolds       //模版文件夹</span><br><span class="line">├── source          //存放用户资源和md文件的地方</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes          //主题文件夹</span><br></pre></td></tr></table></figure><p>修改<code>_config.yml</code>为自己的信息，参考配置文档：<a href="https://hexo.io/zh-cn/docs/configuration">文档</a>。</p><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>建立项目后，第一件事可能是找一个喜欢的主题，在<a href="https://hexo.io/themes/">主题市场</a>找到自己满意的主题进行接下来的安装，当然也可以自己写一个主题。</p><p>找到选好的主题的github项目，将其clone到你新建的项目的themes目录下，这里的默认的一个主题是landscape。修改项目根目录下的<code>_config.yml</code>（项目配置文件，一般主题目录下也有一个<code>_config.yml</code>，请勿混淆），theme的值改为刚才clone的主题名称。到这里就可以将主题应用到项目上，其他配置参考每个主题的文档。</p><h2 id="三、部署"><a href="#三、部署" class="headerlink" title="三、部署"></a>三、部署</h2><p>根据github的规定，仓库名为<code>&lt;your github name&gt;.github.io</code>时默认该仓库的master分支为github page部署分支，此时页面的url为<code>https://&lt;your github name&gt;.github.io/index.html</code>。而其他命名的仓库可以指定一个分支，如gh-pages作为github page部署分支，此时页面的url为<code>https://&lt;your github name&gt;.github.io/repositorie-name/index.html</code>。</p><p>由于这种差异，可以有两种部署方式。一是将hexo项目在本地渲染静态页面，然后push到远程；二是将项目代码同步到github仓库，使用CI将远程渲染后的结果发布到gh-pages分支。</p><h3 id="本地渲染"><a href="#本地渲染" class="headerlink" title="本地渲染"></a>本地渲染</h3><p>由于是部署到github page，所以使用git发布到远程。按照文档，可以使用SFTP等方式发布到自己的服务器上，也可以设置多个发布地址，按顺序发布。</p><p>安装hexo-deployer-git：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-deployer-git --save</span></span><br></pre></td></tr></table></figure><p>修改<code>_config.yml</code>的参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; #git@github.com:xxxx/xxxx.github.io.git</span><br><span class="line">  branch: [branch]</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure><p>需要提前将本地ssh pubkey添加到github的<code>SSH keys</code>里，作为push命令的身份认证。然后只需一条命令就能将网站部署到服务器上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo clean &amp;&amp; hexo deploy</span></span><br></pre></td></tr></table></figure><h3 id="远程渲染"><a href="#远程渲染" class="headerlink" title="远程渲染"></a>远程渲染</h3><p>参考官方文档：<a href="https://hexo.io/zh-cn/docs/github-pages">github-pages</a></p>]]></content:encoded>
      
      <comments>https://marwincn.github.io/2020/02/05/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring Boot + Spring Security 应用开启接口跨域</title>
      <link>https://marwincn.github.io/2019/04/07/SpringBoot%E5%BC%80%E5%90%AF%E6%8E%A5%E5%8F%A3%E8%B7%A8%E5%9F%9F/</link>
      <guid>https://marwincn.github.io/2019/04/07/SpringBoot%E5%BC%80%E5%90%AF%E6%8E%A5%E5%8F%A3%E8%B7%A8%E5%9F%9F/</guid>
      <pubDate>Sun, 07 Apr 2019 03:19:33 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;1-为何要提供跨域资源服务&quot;&gt;&lt;a href=&quot;#1-为何要提供跨域资源服务&quot; class=&quot;headerlink&quot; title=&quot;1.为何要提供跨域资源服务&quot;&gt;&lt;/a&gt;1.为何要提供跨域资源服务&lt;/h2&gt;&lt;p&gt;最近在写的一个项目后端使用了springboot和springsecurity，前端使用Vue和axios（发送ajax）。为了实现前后端分离，后端要开启&lt;code&gt;CORS（跨站资源共享）&lt;/code&gt;，保证后端能对不同站点下的前端提供服务。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于浏览器的同源策略，跨域请求一般会被拒绝，导致ajax无法访问到后端资源。&lt;br&gt;跨域的几种场景，可以判断自己的网站是否跨域：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;域名不同&lt;/li&gt;
&lt;li&gt;域名相同，端口不同&lt;/li&gt;
&lt;li&gt;域名相同，协议不同，如http和https  &lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="1-为何要提供跨域资源服务"><a href="#1-为何要提供跨域资源服务" class="headerlink" title="1.为何要提供跨域资源服务"></a>1.为何要提供跨域资源服务</h2><p>最近在写的一个项目后端使用了springboot和springsecurity，前端使用Vue和axios（发送ajax）。为了实现前后端分离，后端要开启<code>CORS（跨站资源共享）</code>，保证后端能对不同站点下的前端提供服务。</p><blockquote><p>由于浏览器的同源策略，跨域请求一般会被拒绝，导致ajax无法访问到后端资源。<br>跨域的几种场景，可以判断自己的网站是否跨域：  </p><ol><li>域名不同</li><li>域名相同，端口不同</li><li>域名相同，协议不同，如http和https  </li></ol></blockquote><span id="more"></span> <p>了解了为什么要开启CORS后可以开始编写开启CORS的代码了。</p><h2 id="2-Spring-Boot配置里开启CORS"><a href="#2-Spring-Boot配置里开启CORS" class="headerlink" title="2.Spring Boot配置里开启CORS"></a>2.Spring Boot配置里开启CORS</h2><p>springboot开启CORS只需在配置里添加CORS的支持，直接编写配置类即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.CorsFilter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> CorsConfiguration <span class="title">buildConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>); <span class="comment">// 允许的域名</span></span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>); <span class="comment">// 允许的请求头</span></span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>); <span class="comment">// 允许的方法（post、get等）</span></span><br><span class="line">        <span class="keyword">return</span> corsConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, buildConfig()); <span class="comment">// 对接口配置跨域设置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Spring-Security配置"><a href="#3-Spring-Security配置" class="headerlink" title="3.Spring Security配置"></a>3.Spring Security配置</h2><p>由于使用Spring Security后请求都会被它拦截，需要对security也进行配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                <span class="comment">// 如果有允许匿名的url，填在下面</span></span><br><span class="line">                .anyRequest()</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/user/login&quot;</span>)</span><br><span class="line">                <span class="comment">// 自定义处理器，对ajax请求响应json数据</span></span><br><span class="line">                .successHandler(<span class="keyword">new</span> AuthenticationSuccessHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                        httpServletResponse.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">                        PrintWriter out = httpServletResponse.getWriter();</span><br><span class="line">                        <span class="comment">// 将结果转换成Json数据，Result是自己编写的结果类</span></span><br><span class="line">                        JSONObject result = JSONObject.fromObject(<span class="keyword">new</span> Result(Result.SUCCESS, <span class="string">&quot;登录成功！&quot;</span>));</span><br><span class="line">                        out.write(result.toString());</span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 自定义处理器，对ajax请求响应json数据</span></span><br><span class="line">                .failureHandler(<span class="keyword">new</span> AuthenticationFailureHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                        httpServletResponse.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">                        PrintWriter out = httpServletResponse.getWriter();</span><br><span class="line">                        <span class="comment">// 将结果转换成Json数据，Result是自己编写的结果类</span></span><br><span class="line">                        JSONObject result = JSONObject.fromObject(<span class="keyword">new</span> Result(Result.ERROR, <span class="string">&quot;登录失败！&quot;</span>));</span><br><span class="line">                        out.write(result.toString());</span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .usernameParameter(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .logout()</span><br><span class="line">                .logoutUrl(<span class="string">&quot;/logout&quot;</span>)</span><br><span class="line">                .permitAll();</span><br><span class="line">        <span class="comment">// 开启CORS，关闭CSRF跨域</span></span><br><span class="line">        http.cors().and().csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置拦截忽略文件夹，可以对静态资源放行</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/css/**&quot;</span>, <span class="string">&quot;/js/**&quot;</span>, <span class="string">&quot;/js/**&quot;</span>, <span class="string">&quot;/lib/**&quot;</span>, <span class="string">&quot;/upload/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个坑。</p><h2 id="3-1设置CORS和CSRF"><a href="#3-1设置CORS和CSRF" class="headerlink" title="3.1设置CORS和CSRF"></a>3.1设置CORS和CSRF</h2><p>一是，下面这一句必须要设置，否则请求会直接403 Forbidden</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.cors().and().csrf().disable();</span><br></pre></td></tr></table></figure><h2 id="3-2自定义登录处理器"><a href="#3-2自定义登录处理器" class="headerlink" title="3.2自定义登录处理器"></a>3.2自定义登录处理器</h2><p>二是，SpringSecurity通常配置有<code>http.formLogin().successForwardUrl().failureForwardUrl()</code>这几个配置，但是这些配置都是基于服务器渲染页面的模式，在前后端分离项目中登录只用发送携带登录信息的ajax，服务器响应结果即可，开启这些跳转配置会使ajax无法正常获取响应。  </p><p>自定义处理器，登录成功响应对应的结果的Json数据,写到<code>HttpServletResponse</code>中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> AuthenticationSuccessHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        httpServletResponse.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        PrintWriter out = httpServletResponse.getWriter();</span><br><span class="line">        <span class="comment">// 将结果转换成Json数据，Result是自己编写的结果类</span></span><br><span class="line">        JSONObject result = JSONObject.fromObject(<span class="keyword">new</span> Result(Result.SUCCESS, <span class="string">&quot;登录成功！&quot;</span>));</span><br><span class="line">        out.write(result.toString());</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-前端设置"><a href="#4-前端设置" class="headerlink" title="4.前端设置"></a>4.前端设置</h2><p>在跨域请求的时候，通常会自动发送两个请求。第一个请求方法为OPTION，目的是探测后端是否支持跨域，如果支持跨域再发送真实请求。这里是自动发送不用自己编写代码。  </p><p>然后在发送登录请求的时候，会遇到前端ajax发送了username和password参数，但是后端收不到参数而验证失败。这里的原因是，前端ajax比如axios通常以json格式发送数据，请求头中<code>content-type</code>为<code>application/json</code>，但是springsecurity的登录不支持这种格式所以导致错误。  </p><p>解决方法有两种，一是重写SpringSecurity的登录Filter，使其支持json类型数据，操作比较复杂网上有很多相关博客这里就不提了。二是在登录时前端设置数据格式为SpringSecurity支持的application/x-www-form-urlencoded，相关代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> params = <span class="keyword">new</span> URLSearchParams();</span><br><span class="line">params.append(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">params.append(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line"><span class="built_in">this</span>.axios.post(url, params);</span><br></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>至此CORS就已经开启，前端就可以愉快地使用ajax访问后端了。</p>]]></content:encoded>
      
      <comments>https://marwincn.github.io/2019/04/07/SpringBoot%E5%BC%80%E5%90%AF%E6%8E%A5%E5%8F%A3%E8%B7%A8%E5%9F%9F/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
